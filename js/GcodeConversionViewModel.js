//import "file-saver"
/* global saveAs */

// import "knockout"
/* global ko */

/* global JSCut */

import { UnitConverter } from "./UnitConverter.js";
import * as Cam from "./Cam.js";
import { ViewModel } from "./ViewModel.js";

const popovers = [
  { id: "gcodeZeroLowerLeft" },
  { id: "gcodeZeroCenter" },
  { id: "gcodeReturn00" },
  { id: "gcodeOffsetX" },
  { id: "gcodeOffsetY" },
  { id: "gcodeMinX" },
  { id: "gcodeMaxX" },
  { id: "gcodeMinY" },
  { id: "gcodeMaxY" }
]
/**
 * ViewModel for Gcode generation
 */
class GcodeConversionViewModel extends ViewModel {

  /**
   * Note that this view model has it's own unit converter.
   * The gcode generation will generate gcode coordinates in these
   * units. It will also display generation characteristics,
   * such as offsets, in these units.
   */
  constructor() {
    super();

    this.unitConverter = new UnitConverter(this.units);

    this.allowGen = true;

    JSCut.models.Tool.angle.subscribe(() => this.generateGcode());

    /**
     * Gcode generated by this converter
     * @member {string}
     */
    this.gcode = ko.observable("");

    /**
     * Filename to store gcode in
     * @member {string}
     */
    this.gcodeFilename = ko.observable("gcode.gcode");

    /**
     * True to return to 0,0 at the end of the GCode.
     * @member {boolean}
     */
    this.returnTo00 = ko.observable(false);
    this.returnTo00.subscribe(() => this.generateGcode());

    /**
     * Where the origin is. In SVG, the origin is at the top left,
     * and Y increases downwards. Everything else uses clipper
     * coordinates, which follow this pattern. Gcode, on the other hand,
     * may use this, or an inverted coordinate system where Y
     * increases upwards and the origin is at the bottom left of
     * the SVG. To support this we have to be able to select
     * either coordinate system in the generated Gcode.
     */
    this.origin = ko.observable("Bottom Left");
    
    /**
     * Offset of the origin
     */
    this.offsetX = ko.observable(this.unitConverter.fromUnits(0, "mm"));
    this.unitConverter.add(this.offsetX);
    this.offsetX.subscribe(() => this.generateGcode());

    /**
     * Optional offset of the origin from the machine 0,0.
     */
    this.offsetY = ko.observable(this.unitConverter.fromUnits(0, "mm"));
    this.unitConverter.add(this.offsetY);
    this.offsetY.subscribe(() => this.generateGcode());

    // operations view model min/max are in clipper units
    const ovm = JSCut.models.Operations;

    /**
     * Bounding box, in gcode units
     * @member {number}
     */
    this.bbMinX = ko.computed(() => {
      return (this.unitConverter.fromUnits(ovm.bbMinX(), "internal")
              + this.offsetX()).toFixed(4);
    });
    /**
     * Bounding box, in gcode units
     * @member {number}
     */
    this.bbMaxX = ko.computed(() => {
      return (this.unitConverter.fromUnits(ovm.bbMaxX(), "internal")
              + this.offsetX()).toFixed(4);
    });
    /**
     * Bounding box origin, in gcode units
     * @member {number}
     */
    this.bbMinY = ko.computed(() => {
      return (this.unitConverter.fromUnits(ovm.bbMinY(), "internal")
              + this.offsetY()).toFixed(4);
    });
    /**
     * Bounding box, in gcode units
     * @member {number}
     */
    this.bbMaxY = ko.computed(() => {
      return (this.unitConverter.fromUnits(ovm.bbMaxY(), "internal")
              + this.offsetY()).toFixed(4);
    });

    document.addEventListener("toolPathsChanged", () =>
      this.generateGcode());
  }

  // @override
  initialise() {
    this.addPopovers(popovers);

    ko.applyBindings(
      this, document.getElementById("GcodeConversionCard"));

    ko.applyBindings(
      this, document.getElementById("save-gcode-modal"));

    ko.applyBindings(
      this, document.getElementById("simulatePanel"));
  }

  /**
   * Offset coordinates so that 0.0 is at the lower left of all toolpaths.
   * *CAUTION* this is *not* the same as flipping the Y axis. It zeros
   * the origin of the toolpaths being rendered, and *not* the coordinate
   * space of the input SVG.
   */
  zeroLowerLeft() {
    this.allowGen = false;
    const u = this.unitConverter;
    this.offsetX(u.fromUnits(JSCut.models.Operations.bbMinX, "internal"));
    this.offsetY(u.fromUnits(JSCut.models.Operations.bbMaxY, "internal"));
    this.allowGen = true;
    this.generateGcode();
  }

  /**
   * Offset coordinates so that 0.0 is at the centre of all toolpaths.
   * *CAUTION* this zeros the origin of the toolpaths being rendered,
   * and *not* the coordinate space of the input SVG.
   */
  zeroCenter() {
    this.allowGen = false;
    const u = this.unitConverter.units();
    this.offsetX(-(JSCut.models.Operations.bbMinX.toUnits(u)
                   + JSCut.models.Operations.bbMaxX.toUnits(u)) / 2);
    this.offsetY((JSCut.models.Operations.bbMinY.toUints(u)
                  + JSCut.models.Operations.bbMaxY.toUnits(u)) / 2);
    this.allowGen = true;
    this.generateGcode();
  }

  /**
   * Generate gcode for the tool paths specified by the selected
   * operations in the Operations card
   */
  generateGcode() {
    if (!this.allowGen)
      return;

    // Get the set of enabled operations
    const ops = [];
    for (const op of JSCut.models.Operations.operations()) {
      if (op.enabled()) {
        if (op.toolPaths() != null && op.toolPaths().length > 0)
          ops.push(op);
      }
    }
    if (ops.length == 0)
      return;

    const startTime = Date.now();
    console.debug("generateGcode...");

    // Get control values in gcode units
    const gunits = this.unitConverter.units();
    const safeZ = JSCut.models.Material.zSafeMove.toUnits(gunits);
    const rapidRate = JSCut.models.Tool.rapidRate.toUnits(gunits);
    const plungeRate = JSCut.models.Tool.plungeRate.toUnits(gunits);
    const cutRate = JSCut.models.Tool.cutRate.toUnits(gunits);
    const passDepth = JSCut.models.Tool.passDepth.toUnits(gunits);
    const topZ = JSCut.models.Material.topZ.toUnits(gunits);
    /*CPP
    const tabCutDepth = JSCut.models.Tabs.maxCutDepth.toUnits(gunits);
    const tabZ = topZ - tabCutDepth;
    /CPP*/

    if (passDepth < 0) {
      JSCut.showAlert(
        `Pass depth ${passDepth} is less than 0. Will be set to 0.`,
        "alert-warning");
      // Plough on; we might be behaving as a plotter
      passDepth = 0;
    }

    /* CPP
    let tabGeometry = [];
    const tabs = JSCut.models.Tabs.tabs();
    for (let i = 0; i < tabs.length; ++i) {
      const tab = tabs[i];
      if (tab.enabled()) {
        const offset = JSCut.models.Tool.diameter.toUnits("internal")() / 2;
        const geometry = offset(tab.combinedGeometry, offset);
        tabGeometry = ClipperPaths.clip(
          tabGeometry, geometry, ClipperLib.ClipType.ctUnion);
      }
    }*/
    
    const gcode = [];
    switch (gunits) {
    case "inch": gcode.push("G20 ; Set units to inches"); break;
    case "mm": gcode.push("G21 ; Set units to mm"); break;
    default: throw new Error(`${gunits} units not supported by gcode`);
    }
    gcode.push("G90 ; Absolute positioning");
    gcode.push(`G1 Z${safeZ} F${rapidRate} ; Move to clearance level`);
      
    for (const op of ops) {
      const cutDepth = op.cutDepth();
      if (cutDepth < 0) {
        JSCut.showAlert(
          `Operation "${op.name}" has a cut depth which is < 0. Will reset to 0.`,
          "alert-warning");
        // 0 cut depth might be right for plotting
        cutDepth = 0;
      }

      gcode.push(`; ** Operation **`);
      if (op.name() !== "")
        gcode.push(`; Name:        ${op.name()}`);
      gcode.push(`; Type:        ${op.operation()}`);
      gcode.push(`; Paths:       ${op.toolPaths().length}`);
      gcode.push(`; Direction:   ${op.direction()}`);
      gcode.push(`; Cut Depth:   ${cutDepth}${gunits}`);
      gcode.push(`; Pass Depth:  ${passDepth}${gunits}`);
      gcode.push(`; Plunge rate: ${plungeRate}${gunits}/min`);
      gcode.push(`; Cut rate:    ${cutRate}${gunits}/min`);

      gcode.push(...Cam.getGcode({
        paths:          op.toolPaths(),
        ramp:           op.ramp(),
        // Scaling to apply to internal units, to generate Gcode units.
        xScale:         UnitConverter.from.internal.to[gunits],
        yScale:         (this.origin() === "Bottom left"
                         ? -1 : 1) * UnitConverter.from.internal.to[gunits],
        zScale:         1,
        offsetX:        this.offsetX(),
        offsetY:        this.offsetY(),
        //CPP useZ:           op.operation() == "V Pocket",
        //CPP tabGeometry:    tabGeometry,
        //CPP tabZ:           tabZ,
        decimal:        4,
        topZ:           topZ,
        botZ:           topZ - cutDepth,
        safeZ:          safeZ,
        passDepth:      passDepth,
        plungeFeed:     plungeRate,
        retractFeed:    rapidRate,
        cutFeed:        cutRate,
        rapidFeed:      rapidRate
      }));
    }

    if (this.returnTo00())
      gcode.push(`G0 X0 Y0 F${rapidRate} ; Return to 0,0`);
      gcode.push("M2 ; end program");

    this.gcode(gcode.join("\n"));

      console.debug(`generateGcode took ${Date.now() - startTime}`);

    document.dispatchEvent(new Event("updateSimulation"));

    JSCut.tutorial(
      5, 'You\'re done! Look at the "Simulate GCODE" tab. Save your gcode.');
  }

  /**
   * Support for storing gcode in local files.
   * Saves the gcode and hides the modal that invoked the function.
   */
  saveGcodeInLocalFile() {
    const gcode = this.gcode();
    if (gcode == "")
      alert('Click "Generate Gcode" first', "alert-danger");
    else {
      const blob = new Blob([gcode], {type: 'text/plain'});
      saveAs(blob, this.gcodeFilename());
    }
    this.hideModal("save-gcode-modal");
  }

  // @override
  get jsonFieldName() { return 'gcodeConversion'; }

  // @override
  toJson() {
    return {
      units: this.unitConverter.units(),
      gcodeFilename: this.gcodeFilename(),
      offsetX: this.offsetX(),
      offsetY: this.offsetY()
    };
  }

  // @override
  fromJson(json) {
    this.updateObservable(json, 'units');
    this.updateObservable(json, 'gcodeFilename');
    this.updateObservable(json, 'offsetX');
    this.updateObservable(json, 'offsetY');
  };
}

export { GcodeConversionViewModel }
